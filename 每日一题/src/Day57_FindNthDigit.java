public class Day57_FindNthDigit {
    /**
     *   基本规律:
     *     [1, 9]        有9 * 1个数字     => 9 * 1 * 1     => 9 * 10^0 * 1
     *     [10, 99]      有90 * 2个数字    => 9 * 10 * 2    => 9 * 10^1 * 2
     *     [100, 999]    有900 * 3个数字   => 9 * 100 * 3   => 9 * 10^2 * 3
     *     [1000, 9999]  有9000 * 4个数字  => 9 * 1000 * 4  => 9 * 10^3 * 4
     *                                                     => 9 * 10^(n-1) * n
     *      ...
     * @param n
     * @return
     */
    public int findNthDigit(int n) {
        //首先我们可以根据n来计算出它所属的数字是多少
        //基数9, 每轮十倍递增
        int len = 1;
        while (len * 9 * Math.pow(10, len - 1) < n) {
            n -= len * 9 * Math.pow(10, len - 1);
            len++;
        }
        //由于每个数长度都是 len，因此我们可以用剩余的数 n 除 len，
        //得到从起点的偏移量是多少（并将偏移量累加更新到 s），
        //然后对 n 做第二阶段的试减，
        //如果试减后结果恰好为 0，那么答案为当前 s的最后一个数字；
        //否则（试减结果大于 0），则是 x + 1 中（十进制表示，从左往右数）的第 n 个数字。
        long s = (long) Math.pow(10, len - 1);
        s += n / len - 1;
        n -= len * (n / len);
        return n == 0 ? (int) (s % 10) : (int) ((s + 1) / Math.pow(10, len - n) % 10);

    }
}
